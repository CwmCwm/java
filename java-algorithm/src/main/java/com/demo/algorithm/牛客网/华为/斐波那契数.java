package com.demo.algorithm.牛客网.华为;


/**
 * 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
 * F(0) = 0，F(1) = 1
 * F(n) = F(n - 1) + F(n - 2)，其中 n > 1
 * 给定 n ，请计算 F(n) 。
 * 结果可能过大，因此结果需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 *
 *
 *
 * 今天的有氧运动训练内容是在一个长条形的平台上跳跃。平台有 num 个小格子，每次可以选择跳 一个格子 或者 两个格子。请返回在训练过程中，学员们共有多少种不同的跳跃方式。
 * 结果可能过大，因此结果需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 * f(n)=f(n-1)+f(n-2)是怎么来的。
 * 由于青蛙每次只能跳一格或者两格，那么最后跳的这次确定了，只需要得到第n-1阶的跳法可以得到最后一次跳一部跳到终点的种数，得到第n-2阶的跳法就可以得到最后一次跳两格的跳法种数，相加即得到跳达终点的跳法数
 * 是上面斐波那契数的变种，算法一致，只是起始一样，这里 F(0)=1,F(1)=1,F(2)=2
 */
public class 斐波那契数 {



    //以数组的方式，记录了所有数据
    public int method1(int n) {
        //动态规划
        int[] dp = new int[n+1];
        if(n==0) return 0;
        if(n==1) return 1;

        dp[0] = 0;
        dp[1] = 1;
        for (int i=2; i<=n; i++) {
            dp[i] = (dp[i-1] + dp[i-2])%1000000007;
        }
        return dp[n];
    }

    //只保存3个值，不断更新这3个值，直到n
    public int method2(int n) {
        int F_n_2 = 0;//F(n-2)
        int F_n_1 = 1;//F(n-1)
        int F_n = 1;  //F(n)

        if(n==0) return 0;
        for (int i=2; i<n; ++i) {
            F_n_2 = F_n_1;
            F_n_1 = F_n;
            F_n = (F_n_2+F_n_1) % 1000000007;
        }
        return F_n;
    }

}
