
前提知识：计算机组成，计算机原理

JVM Java Virtual Machine（Java虚拟机）     
（虚拟机这种工程分层已经是常见套路了，任何一种扩平台/扩操作系统都会使用虚拟机这种套路，其他语言也有虚拟机啊）

## JVM从编译到执行   Java程序的执行过程
过程如下：Java文件 -> 编译器 > 字节码 -> JVM -> 机器码。  
步骤一：业务程序员写Java代码，经过编译，将Java代码编译成字节码   
步骤二：运行main时，JVM将字节码翻译成机器码，这样就能调用通过操作系统使用计算机资源    
（各个步骤是分离的，这很符合工程学套路--分层/模块，所以还有其他Kotlin语言和Scala语言，就是对步骤一进行修改，反正步骤一的产生就是字节码，至于步骤一具体怎么操作你自己操作 ）



## JVM、JRE、JDK 的关系
JVM： 运行字节码   
JRE： 运行时的java类库，就是规范化的基础代码（网络/磁盘/IO/基础规范，JDBC，RMI，JavaServlet，JTA，JTS 等等，因为计算机底层已经沉淀下来，必然会有基础代码）    
JDK： 编写java的类库（就比上面JRE多写类库，用于支持写java代码）  
其实没啥好说的，这种知识没哈卵用/不关键，你工作自然而然就会知道



## 从跨平台到跨语言  
跨平台  
因为有虚拟机这一套路，所以都能跨平台/跨操作系统   
对比C语言（很多开源基础软件是提供C源码，如果你在window系统，通过window上的VC，编译C源码成机器码，就可以在window上运行开源软件，
如果你在Linux系统，通过Linux的gcc，编译C源码成机器码，就可以在window上运行开源软件了）

跨语言  
JVM只是将字节码翻译成机器码（那字节码我就不管你怎么来的了，你将JavaScript源码编译成字节码，JVM照样可以运行，你甚至将C源码编译成字节码都可以，但是没必要，因为C有它自己的工具链和生态和场景）   
（生态这种东西，就是正反馈越来越强，除非一些不可抗力）



## JVM 的发展（非重点）
百度历史
常见的JVM实现：Hotspot  和 其他（其他见百度）



## JVM 的内存区域（内存模型）    我只能说，我不关注，下面对我来说只是补充知识，不是关键知识（劳动中用不上）     
图见pdf笔记  
线程私有区： 由很多个虚拟机栈组成（理解成线程，因为创建一个线程，就会创建一个虚拟机栈，销毁同理）   
  虚拟机栈的数据结构和执行流程
  栈的数据结构：先进后出(FILO)的数据结构，
  栈帧：在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。  栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址) 
  程序计数器  
（关于线程是如何运行代码，如何调用CPU，如何存取内存，基本原理就是通过栈这种数据结构实现的，应该看操作系统的知识）

本地方法栈：本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。 
但本地方法并不是 用 Java 实现的，而是由 C 语言实现的(比如 Object.hashcode 方法)。它服务的对象是 native 方法。

方法区（Method Area）： 是可供各条线程共享的运行时内存区域。它存储了每一个类的结构信息，
例如运行时常量池（Runtime Constant Pool） 字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法
方法区是 JVM 对内存的“逻辑划分”(是一种规范/概念)，  
在 JDK1.7 及之前很多开发者都习惯将方法区称为“永久代”（是一种实现）， 是因为在 HotSpot 虚拟机中，设计人员使用了永 久代来实现了 JVM 规范的方法区。
在 JDK1.8 及以后使用了元空间（是另一种实现）来实现方法区

运行时常量池（Runtime Constant Pool）：是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，
它包括了若干种不同的常量：从编 译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。 
运行时常量池是方法区的一部分。



  





































